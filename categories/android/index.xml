<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Android on Learn Or Die</title><link>https://neohsu.github.io/categories/android/</link><description>Recent content in Android on Learn Or Die</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 05 Nov 2014 18:13:58 +0800</lastBuildDate><atom:link href="https://neohsu.github.io/categories/android/index.xml" rel="self" type="application/rss+xml"/><item><title>How to check your internet connection</title><link>https://neohsu.github.io/posts/2014-11-05-how-to-check-your-internet-connection/</link><pubDate>Wed, 05 Nov 2014 18:13:58 +0800</pubDate><guid>https://neohsu.github.io/posts/2014-11-05-how-to-check-your-internet-connection/</guid><description>查詢目前的手機上，是否有網路連線並判斷目前連線的模式，有很多方式可以去做查詢，下面是很多人常用的方式
上方程式區塊可以查詢到目前網路是否連線並確認連線模式 ( 3G / Wifi ) 後，變回傳相對應的值給 Caller
但是最近在 Nexus 7 上運行該功能時發生了 Crash 的狀況
主要原因是在目前 Android 平板裝置上，有些裝置不一定有配置 3G 的模組，因此會在運行到 ConnectivityManager.TYPE_MOBILE 時，因為找不到相關資訊而導致 Crash
目前我想到的解決方式只能用改變順序的方式去避過這樣的錯誤，靠著先判斷網路連線和 Wifi 狀況而不去使用 TYPE_MOBILE 模式來偵測
感覺改變順序做法上有點難看，但是還是可以解一下燃眉之急啊！但是由上面例子可以讓我們重新思考，是不是有些例外處理自己沒有做好呢？真改好好反省一下&amp;hellip;</description></item><item><title>Activity LaunchMode</title><link>https://neohsu.github.io/posts/2014-11-03-activity-launchmode/</link><pubDate>Mon, 03 Nov 2014 17:50:23 +0800</pubDate><guid>https://neohsu.github.io/posts/2014-11-03-activity-launchmode/</guid><description>最近遇到 onActivityResult 沒有反應的問題，找了些許資料後才發現原來自己忽略了 Activity 啟動的原點，這邊紀錄一下 Activity 的啟動模式
Activity 的啟動模式在 androidManifest.xml 中設定
&amp;lt;activity android:name=&amp;#34;.MainActivity&amp;#34; android:launchMode=&amp;#34;standard&amp;#34;&amp;lt;/activity&amp;gt; Activity LaunchMode standard : 每次 startActivity 都會產生新的 Activity Instance singleTop : 當 startActivity 已經有相同的 Activity Instance 在佇列中，且是 Top 狀態時，不產生新的 Activity Instance singleTask : 所有 startActivity 都會產生唯一的 Activity Instance 並存在於主 Task 中 singleInstance : 當 startActivity 後該 Activity 會存於在和主 Task 不同的 Task 中且 Activity Instance 是唯一的 Standard Example standard 為 Activity LaunchMode 的預設值，如果沒有設定 LaunchMode 就會以 standard 來運行 使用 Standard 運作原理如下</description></item><item><title>HowTo: ListView Optimization About Custom Adapter and Layout</title><link>https://neohsu.github.io/posts/2013-12-13-howto-listview-optimization-about-custom-adapter-and-layout/</link><pubDate>Fri, 13 Dec 2013 23:08:46 +0800</pubDate><guid>https://neohsu.github.io/posts/2013-12-13-howto-listview-optimization-about-custom-adapter-and-layout/</guid><description>Adapter 的作用就是 ListView 與資料之間的橋樑，當 ListView 中每一個 Item 顯示到螢幕上時，都會調用 Adapter 的 getView 方法返回一個View，因此當 ListView 在處理 Scroll 事件時，會反覆的調用 getView 方法去顯示頁面，使頁面不斷的重複建立相同的 View ，因此會產生記憶體不足而導致閃退或是滾動不夠順暢的狀況；由此可見我們應該要在調用 getView 方法時做些優化，以增進 ListView 的效能
ListView 優化的思路整理以下兩種：
View 的重復使用：
View 每次創建是比較耗費時間的動作，因此對於 getView 方法傳入的 converView 應該充分利用 Null 的判斷 ViewHolder 的應用：
View 在調用 findViewById 方法也是比較耗時的，因此需要考慮只調用一次，之後就調用 View.getTag 方法來取得 ViewHolder 物件 BaseAdapter Example 繼承 BaseAdapter 之後需要重寫四個方法：getCount，getItem，getItemId 和 getView
BaseAdapter 一開始會先調用 getCount 來計算將會顯示的 Item 數，因此我們需先回傳該值 為了反覆取用之前已建立過的 View，我們利用 ViewHolder 保存已建立的 View；這邊可以存取 Item 中所顯示的元件 當 BaseAdapter 調用 getView 時，我們可以從 converView 中確認 View 是否存在，如果存在則從 ViewHolder 中取出，如果未存在則建立新的 View 並設定 tag 記錄已建立過；當指定好 Holder 後，便利用 Holder 去執行所需要的配置與相對應的事件了 BaseAdapter 完整範例的原始碼 GitHub - NeoHsu/CustomListViewWithBaseAdapter</description></item><item><title>Talk About ListView Adapter on Android</title><link>https://neohsu.github.io/posts/2013-12-12-talk-about-listview-and-adapter-on-android/</link><pubDate>Thu, 12 Dec 2013 23:02:24 +0800</pubDate><guid>https://neohsu.github.io/posts/2013-12-12-talk-about-listview-and-adapter-on-android/</guid><description>在 Android 開發過程中，ListView 和 Adapter 有著密不可分的關係；Adapter 主要負責 Data 和 ListView 之間資料配置與 Layout 佈局的媒介，因此在實作 Custom ListView 時，常會針對 Adapter 組件去做客製化的設計；下面將介紹 Adapter 和 ListView 之間的運作原理並說明不同資料形態的 Adapter 運作模式
{% img /images/SVG/0-talk-about-listview-and-adapter-on-android.png %}
一般而言 ListView 是由以下三個元素所组成，
View：
用來顯示 ListView 中每一個 Item 所要呈現的配置 Adapter：
將不同的資料對應到 View 中，不同的資料使用不同的 Adapter 去做對應，如 ArrayAdapter，CursorAdapter，SimpleAdapter 等，Adapter 會將資料對應到 ListView Item 的 View 中來呈現資料 Data：
Adapter 所需要對應的資料來源，資料形態可以是字串或圖片，儲存資料的媒介可以是 ArrayList 或 Cursor 並透過 Adapter 將資料放到 Item 中；所有的資料會顯示到 ListView 上都是透過 Adapter 來完成 根據上圖我們可以知道當使用 ListView 時，我們會先將要放入 ListView 的資料丟入 Adapter 中， Adapter 透過 XML 中 Layout 的佈局去配置每個 Item 的樣式與資料，最後再將配置好的佈局放入 ListView 中呈現出我們所設定的樣式；事實上系統已有預設的 Adapter 可以運用，但有時候並不能滿足我們的需求，因此要實現複雜的 ListView 可以透過繼承 Adapter 並重寫相對應的方法即可；以下將介紹一下透過不同 Adapter 的運作過程</description></item><item><title>Talk About View Component On Android</title><link>https://neohsu.github.io/posts/2013-12-11-talk-about-view-component-on-android/</link><pubDate>Wed, 11 Dec 2013 22:51:29 +0800</pubDate><guid>https://neohsu.github.io/posts/2013-12-11-talk-about-view-component-on-android/</guid><description>{% img /images/SVG/1-talk-about-view-component-on-android.svg %}
在 Android 開發中，我認為了解 View 的執行過程有助於提高介面呈現的效率，可以幫助一些複雜 Layout 在適當的時機中處理，或是可以減少不必要的畫面重製，這些都是對於 View 的執行過程有很大的關聯
Android 中 View 的呈現主要經過 Mesure, Layout 和 Draw 這三個過程：
Mesure 此階段主要是負責計算 view 佔用的大小，簡單的說就是將 match_parent 和 wrap_content 轉成目前顯示的實際大小；透過 onMeasure(widthMeasureSpec, heightMeasureSpec) 方法去處理計算 View 在目前螢幕上顯示的區塊大小
View 的大小是有 Parent View 和自己的大小决定而不是單一個 View 來决定，因此需要配合自己的 Sub-View 去做計算調整
Layout 當 View 配置好大小後，便讀取設定好的 Layout 配置，將 Layout 佈局放到建立好的 View 中並計算出 View 在螢幕上的座標；透過 onLayout(int l, int t, int r, int b )方法去處理
處理組件的佈局通常要重寫 onMesure 和 onLayout 這兩個方法</description></item><item><title>Error : ADB Server didn't ACK on Windows</title><link>https://neohsu.github.io/posts/2013-11-28-solve-adb-server-didnt-ack-on-windows/</link><pubDate>Thu, 28 Nov 2013 23:40:27 +0800</pubDate><guid>https://neohsu.github.io/posts/2013-11-28-solve-adb-server-didnt-ack-on-windows/</guid><description>Outline 產生ADB Server didn&amp;rsquo;t ACK 問題的主要原因為 ADB Server 的 Port 绑定失败，因此只需要關閉 Adb Server 所需綁定的 Port 上佔用的程序即可；我是在使用 Windows 系統時，自動啟動的 QQ 即時通訊軟體使 ADB Server 需綁定的 Port 被佔用，因此產生此問題
Quit Eclipse &amp;amp; Open Command Line 關閉 Eclipse 使 android 的 adb與Eclipse 間的連結關閉，並打開 commad line ，切換目錄到 Android SDK 目錄中 platform-tools 資料夾裡
切換到 platform-tools 資料夾中是為了使用 adb 工具，如果有有將 platform-tools 資料夾路徑加到環境變數中可以不需要切換
Turn Off ADB Server &amp;amp; Turn On ADB Server Again 關閉並重新啟動 ADB Server
IF Failed To Start ADB Server 如果前面步驟還沒成功啓動 ADB Server ，則需要查詢有哪些程序佔用了 ADB Server 的 port</description></item></channel></rss>